(define (domain transport)
    (:requirements :derived-predicates :existential-preconditions :negative-preconditions :typing)
    (:types package vehicle - locatable locatable location size - object)
    (:predicates (at ?x - locatable ?v - location)  (at_AG ?x - locatable ?v - location)  (at_G ?x - locatable ?v - location)  (at_UG ?x - locatable ?v - location)  (capacity ?v - vehicle ?s1 - size)  (capacity-predecessor ?s1 - size ?s2 - size)  (capacity-predecessor_AG ?s1 - size ?s2 - size)  (capacity-predecessor_G ?s1 - size ?s2 - size)  (capacity-predecessor_UG ?s1 - size ?s2 - size)  (capacity_AG ?v - vehicle ?s1 - size)  (capacity_G ?v - vehicle ?s1 - size)  (capacity_UG ?v - vehicle ?s1 - size)  (derivable_drive) (derivable_drop) (derivable_pick-up) (drive_ ?v - vehicle ?l1 - location ?l2 - location)  (drop_ ?v - vehicle ?l - location ?p - package ?s1 - size ?s2 - size)  (in ?x - package ?v - vehicle)  (in_AG ?x - package ?v - vehicle)  (in_G ?x - package ?v - vehicle)  (in_UG ?x - package ?v - vehicle)  (pick-up_ ?v - vehicle ?l - location ?p - package ?s1 - size ?s2 - size)  (road ?l1 - location ?l2 - location)  (road_AG ?l1 - location ?l2 - location)  (road_G ?l1 - location ?l2 - location)  (road_UG ?l1 - location ?l2 - location))
    (:derived (at_AG ?x - locatable ?v - location) (and (at ?x ?v) (at_G ?x ?v)))
     (:derived (at_UG ?x - locatable ?v - location) (and (not (at ?x ?v)) (at_G ?x ?v)))
     (:derived (capacity-predecessor_AG ?s1 - size ?s2 - size) (and (capacity-predecessor ?s1 ?s2) (capacity-predecessor_G ?s1 ?s2)))
     (:derived (capacity-predecessor_UG ?s1 - size ?s2 - size) (and (not (capacity-predecessor ?s1 ?s2)) (capacity-predecessor_G ?s1 ?s2)))
     (:derived (capacity_AG ?v - vehicle ?s1 - size) (and (capacity ?v ?s1) (capacity_G ?v ?s1)))
     (:derived (capacity_UG ?v - vehicle ?s1 - size) (and (not (capacity ?v ?s1)) (capacity_G ?v ?s1)))
     (:derived (derivable_drive) (exists (?l1 - location ?v - vehicle ?l2 - location) (and (at ?v ?l1) (drive_ ?v ?l1 ?l2))))
     (:derived (derivable_drop) (exists (?s1 - size ?s2 - size ?v - vehicle ?p - package ?l - location) (and (at ?v ?l) (in ?p ?v) (capacity-predecessor ?s1 ?s2) (capacity ?v ?s1) (drop_ ?v ?l ?p ?s1 ?s2))))
     (:derived (derivable_pick-up) (exists (?s1 - size ?s2 - size ?v - vehicle ?p - package ?l - location) (and (at ?v ?l) (at ?p ?l) (capacity-predecessor ?s1 ?s2) (capacity ?v ?s2) (pick-up_ ?v ?l ?p ?s1 ?s2))))
     (:derived (drive_ ?V - vehicle ?L1 - location ?L2 - location) (exists (?P) (and (in ?P ?V) (at_UG ?P ?L2) (not (derivable_pick-up)) (not (derivable_drop)))))
     (:derived (drive_ ?V - vehicle ?L1 - location ?L2 - location) (exists (?S ?P ?S2 ?L3) (and (at ?P ?L2) (at_UG ?P ?L3) (not (derivable_pick-up)) (not (derivable_drop)) (capacity ?V ?S) (capacity-predecessor ?S2 ?S))))
     (:derived (drop_ ?V - vehicle ?L - location ?P - package ?S1 - size ?S2 - size) (at_UG ?P ?L))
     (:derived (in_AG ?x - package ?v - vehicle) (and (in ?x ?v) (in_G ?x ?v)))
     (:derived (in_UG ?x - package ?v - vehicle) (and (not (in ?x ?v)) (in_G ?x ?v)))
     (:derived (pick-up_ ?V - vehicle ?L - location ?P - package ?S1 - size ?S2 - size) (exists (?G) (at_UG ?P ?G)))
     (:derived (road_AG ?l1 - location ?l2 - location) (and (road ?l1 ?l2) (road_G ?l1 ?l2)))
     (:derived (road_UG ?l1 - location ?l2 - location) (and (not (road ?l1 ?l2)) (road_G ?l1 ?l2)))
    (:action drive
        :parameters (?v - vehicle ?l1 - location ?l2 - location)
        :precondition (and (at ?v ?l1) (drive_ ?v ?l1 ?l2))
        :effect (and (not (at ?v ?l1)) (at ?v ?l2))
    )
     (:action drop
        :parameters (?v - vehicle ?l - location ?p - package ?s1 - size ?s2 - size)
        :precondition (and (at ?v ?l) (in ?p ?v) (capacity-predecessor ?s1 ?s2) (capacity ?v ?s1) (drop_ ?v ?l ?p ?s1 ?s2))
        :effect (and (not (in ?p ?v)) (at ?p ?l) (capacity ?v ?s2) (not (capacity ?v ?s1)))
    )
     (:action pick-up
        :parameters (?v - vehicle ?l - location ?p - package ?s1 - size ?s2 - size)
        :precondition (and (at ?v ?l) (at ?p ?l) (capacity-predecessor ?s1 ?s2) (capacity ?v ?s2) (pick-up_ ?v ?l ?p ?s1 ?s2))
        :effect (and (not (at ?p ?l)) (in ?p ?v) (capacity ?v ?s1) (not (capacity ?v ?s2)))
    )
)